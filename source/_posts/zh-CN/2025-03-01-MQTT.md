---
title: MQTT
comments: true
published: true
lang: zh-CN
date: 2025-03-01 23:20:48
updated:
tags:
- 通信协议
- MQTT
categories:
- [系统架构, 通信协议, MQTT]
---

# MQTT 协议学习笔记

## 封面

- **标题**：MQTT 协议学习笔记
- **作者**：vector.qiu
- **创建日期**：2025-02-16
- **更新日期**：2025-02-16

------

## 修改记录

- **2025-02-16 (v1.0.0) ：**：
  - 初始版本，完成 MQTT 协议学习笔记的整理。
  - 添加了协议基础、核心知识点及实践案例。
  - 作者：vector.qiu

------

## 目录

- [MQTT 协议学习笔记](#mqtt-协议学习笔记)
  - [封面](#封面)
  - [修改记录](#修改记录)
  - [目录](#目录)
  - [引言](#引言)
    - [学习目标](#学习目标)
    - [适用人群](#适用人群)
    - [前置知识](#前置知识)
    - [学习方法](#学习方法)
  - [基础概念](#基础概念)
    - [定义与背景](#定义与背景)
    - [术语解释](#术语解释)
    - [核心原理](#核心原理)
  - [核心知识点](#核心知识点)
    - [模块 1：MQTT 协议版本](#模块-1mqtt-协议版本)
      - [概述](#概述)
      - [详细讲解](#详细讲解)
      - [注意事项](#注意事项)
      - [小结](#小结)
    - [模块 2：MQTT 报文格式](#模块-2mqtt-报文格式)
      - [概述](#概述-1)
      - [详细讲解](#详细讲解-1)
      - [注意事项](#注意事项-1)
      - [小结](#小结-1)
  - [实践案例](#实践案例)
    - [案例背景](#案例背景)
    - [解决思路](#解决思路)
    - [实现过程](#实现过程)
    - [结果展示](#结果展示)
    - [优化建议](#优化建议)
  - [常见问题与解决方案](#常见问题与解决方案)
    - [FAQ](#faq)
    - [错误排查](#错误排查)
    - [经验分享](#经验分享)
  - [资源推荐](#资源推荐)
    - [书籍](#书籍)
    - [在线课程](#在线课程)
    - [工具与软件](#工具与软件)
    - [社区与论坛](#社区与论坛)
  - [总结与展望](#总结与展望)
    - [学习收获](#学习收获)
    - [未来计划](#未来计划)
    - [感谢](#感谢)
  - [附录](#附录)
    - [术语表](#术语表)
    - [参考文献](#参考文献)
    - [索引](#索引)

------

## 引言

### 学习目标

通过本笔记，掌握 MQTT 协议的基本概念、工作原理及核心功能，能够熟练使用 MQTT 进行物联网设备通信，并了解不同版本的差异及应用场景。

### 适用人群

适合物联网开发者、嵌入式工程师以及对消息传输协议感兴趣的初学者和进阶者。

### 前置知识

- 网络基础知识（TCP/IP 协议）
- 嵌入式系统开发基础
- 基本编程能力（C/C++ 或 Python）

### 学习方法

理论结合实践，通过阅读协议规范、分析报文格式并动手实现简单的 MQTT 客户端或服务器来加深理解。

------

## 基础概念

### 定义与背景

MQTT（Message Queuing Telemetry Transport）是一种基于发布/订阅模式的消息传输协议，专为资源受限设备和低带宽、不稳定网络环境设计。广泛应用于物联网（IoT）、移动应用等领域。

- **轻量级和高效**：MQTT 协议的报文格式非常简单，占用带宽小，适用于物联网（IoT）、移动应用等对网络带宽和功耗要求严格的场景。
- **发布/订阅模式**：MQTT 使用发布/订阅的通信模式，设备（客户端）通过向特定主题发布消息或订阅主题来接收消息。
- **可靠的消息传输**：支持三种服务质量（QoS）等级，分别为“最多一次”（0）、“至少一次”（1）和“只有一次”（2），确保消息的传递可靠性。
- **灵活的主题结构**：MQTT 允许使用层级主题和通配符进行消息过滤和订阅，适应复杂的通信需求。

### 术语解释

- Broker ：消息代理，负责接收和转发消息。
- Client ：客户端，可以是消息的发布者或订阅者。
- Topic ：主题，用于标识消息类别。
- QoS ：服务质量等级，分为 0（最多一次）、1（至少一次）、2（仅一次）。
- Will Message ：遗嘱消息，在客户端异常断开时发送。

### 核心原理

MQTT 使用 TCP/IP 协议作为底层传输层，采用发布/订阅模式实现消息传递。客户端通过连接到 Broker 发布或订阅消息，Broker 负责将消息路由到订阅者。

------

## 核心知识点

### 模块 1：MQTT 协议版本

#### 概述

MQTT 协议有多个版本，包括 v3.1、v3.1.1 和 v5.0，每个版本在功能和复杂性上有所不同。

#### 详细讲解

- MQTT v3.1 ：
  - **发布日期**: 2010年
  - 特点:
    - 最初由 IBM 和 Eurotech 开发，作为事实上的行业标准。
    - 提供基本的发布/订阅消息传输机制，适合低带宽和高延迟的网络环境。
    - 定义了基本的 `CONNECT`、`PUBLISH`、`SUBSCRIBE`、`UNSUBSCRIBE`、`DISCONNECT` 等报文类型。
    - 支持 QoS (服务质量) 级别：0、1、2，分别对应最多一次、至少一次和仅一次的消息传递语义。
  - 局限性:
    - 规范不够详细，容易导致不同实现之间的互操作性问题。
    - 缺乏正式标准化，协议名称为 `MQIsdp`。
- MQTT v3.1.1 ：
  - **发布日期**: 2014年
  - 特点:
    - 由 OASIS 标准委员会批准和发布，成为正式的行业标准。
    - 解决了 v3.1 版本中的一些不明确之处，增强了协议的清晰性和互操作性。
    - 改进了错误处理机制，特别是在 `CONNACK` 报文的返回码上。
    - 改进了连接保持（Keep Alive）机制，更明确地规定了超时处理。
    - 协议名称更改为 `MQTT`，版本号字段值为 `0x04`。
  - 优点:
    - 更加稳健和清晰的协议规范。
    - 增强了不同设备和平台之间的兼容性。
  - **广泛应用**: 是目前最广泛使用的 MQTT 版本，适用于大多数物联网和嵌入式应用。
- MQTT v5.0 ：
  - **发布日期**: 2019年
  - 特点:
    - 由 OASIS 发布的最新版本，旨在增强灵活性、扩展性和错误处理能力。
    - 引入了属性（Properties）机制，允许在报文中携带更多的元数据。
    - 增加了用户自定义的错误代码，增强了错误处理的灵活性。
    - 支持消息延迟投递（Message Expiry）和响应主题（Response Topic），提高了应用的灵活性。
    - 引入了共享订阅和请求/响应模式，优化了客户端和服务器的交互。
  - 优点:
    - 更强大的功能和扩展性，适应更多复杂的应用场景。
    - 提高了对大规模分布式系统的支持能力。
  - 局限性:
    - 由于功能的增强，协议的复杂性也有所增加，可能不适合资源非常受限的设备。
  - **适用场景**: 适用于对扩展性和灵活性有较高要求的现代物联网应用。

#### 注意事项

新项目应优先选择 v3.1.1 或 v5.0。
资源受限设备可考虑使用 v3.1 或 MQTT-SN。

#### 小结

MQTT v3.1.1 是目前最常用的版本，v5.0 提供了更多高级功能，适用于复杂场景。

### 模块 2：MQTT 报文格式

#### 概述

MQTT 报文由固定报头、可变报头和负载组成，每种报文类型（如 CONNECT、PUBLISH）有不同的格式。

工作流程

1. **连接（CONNECT）**：客户端向 MQTT 服务器（通常称为“代理”或“Broker”）发送连接请求，包含客户端标识符、用户名、密码、遗嘱消息等信息。
2. **连接确认（CONNACK）**：服务器响应连接请求，确认连接是否成功，以及是否有会话需要恢复。
3. **发布消息（PUBLISH）**：客户端发布消息到某个主题，消息通过代理转发给订阅该主题的所有客户端。
4. **订阅主题（SUBSCRIBE）**：客户端向服务器发送订阅请求，指定要接收的消息主题。
5. **订阅确认（SUBACK）**：服务器确认订阅请求，指示订阅是否成功。
6. **取消订阅（UNSUBSCRIBE）**：客户端取消对某个主题的订阅。
7. **取消订阅确认（UNSUBACK）**：服务器确认取消订阅请求。
8. **心跳检测（PINGREQ 和 PINGRESP）**：客户端和服务器通过心跳消息维持连接的活跃状态。
9. **断开连接（DISCONNECT）**：客户端主动断开与服务器的连接。

> MQTT v3.1 和 v3.1.1 都是轻量级的消息传输协议，主要用于物联网设备之间的通信。虽然这两个版本之间存在一些差异，但它们的基本协议格式在 CONNECT、CONNACK、PUBLISH、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK、PINGREQ、PINGRESP 和 DISCONNECT 报文的结构上大致相同。

#### 详细讲解

- **CONNECT 报文**
    CONNECT 报文用于客户端与服务器建立连接。

    MQTT v3.1 和 v3.1.1 格式

    | 字节偏移 | 名称               | 描述                                                         |
    | -------- | ------------------ | ------------------------------------------------------------ |
    | 0        | 固定报头 (1字节)   | 报文类型（1-4位），剩余长度（第2字节之后）                   |
    | 1        | 剩余长度           | 剩余报文长度，使用可变长度编码                               |
    | 2-3      | 协议名长度         | 表示协议名的长度（高字节在前），MQIsdp（v3.1），MQTT（v3.1.1） |
    | 4-7      | 协议名             | “MQIsdp” 或 “MQTT”                                           |
    | 8        | 协议版本号         | 0x03（v3.1），0x04（v3.1.1）                                 |
    | 9        | 连接标志           | 包含连接标志位，如清除会话、用户名标志、密码标志、Will 标志等 |
    | 10-11    | 保持连接时间       | 心跳保持时间（以秒为单位），表示客户端和服务器之间的最长允许空闲时间 |
    | 12-...   | 可变头部和有效载荷 | 包含客户端标识符、Will Topic、Will Message、用户名、密码等字段 |

  - **CONNECT 报文格式**

    `CONNECT` 报文由以下几部分组成：

    1. 固定头部（Fixed Header）
       - **报文类型**：4 位，用于指定 MQTT 报文的类型，对于 `CONNECT` 报文，其值为 `0001`。
       - **剩余长度**：表示可变头部和有效载荷的字节总数。
    2. 可变头部（Variable Header）'
       - 可变头部包含协议名称、协议级别、连接标志和保持连接（Keep Alive）计时器。
       - **协议名（Protocol Name）**：例如 "MQTT"。
       - **协议级别（Protocol Level）**：例如 `0x04` 对应 MQTT v3.1.1。
       - **连接标志（Connect Flags）**：这是一个 1 字节的字段，用于设置包括遗嘱消息在内的多个连接参数。
         - **用户名标志（User Name Flag）**：位于第 7 位，用于指示是否包含用户名。
         - **密码标志（Password Flag）**：位于第 6 位，用于指示是否包含密码。
         - **遗嘱标志（Will Flag）**：位于第 2 位。如果设置为 `1`，表示启用遗嘱消息；如果为 `0`，则不启用。
         - **遗嘱 QoS（Will QoS）**：位于第 3 和第 4 位，用于指定遗嘱消息的服务质量（QoS）。
         - **遗嘱保留标志（Will Retain）**：位于第 5 位，指示遗嘱消息是否保留。
         - **清理会话标志（Clean Session）**：位于第 1 位，用于指示是否清理客户端的状态信息。
       - **保持连接（Keep Alive）**：一个 2 字节的字段，用于设置客户端和服务器之间的保持连接时间间隔。
    3. 有效载荷（Payload）
        有效载荷中包含的内容与连接标志中设置的字段相关，具体包括：]
        - **客户端标识符（Client Identifier）**：标识客户端的唯一标识符。
        - **遗嘱主题（Will Topic）**：如果启用了遗嘱消息，这里会包含遗嘱消息的主题。
        - **遗嘱消息（Will Message）**：如果启用了遗嘱消息，这里会包含遗嘱消息的内容。
        - **用户名（User Name）**：如果连接标志中设置了用户名标志，这里会包含用户名
        - **密码（Password）**：如果连接标志中设置了密码标志，这里会包含密码。

  - **遗嘱消息在 CONNECT 报文中的设置**

    假设你要设置一个带有遗嘱消息的 `CONNECT` 报文，流程如下：

    1. **将 Will Flag 设置为 1**：表示启用遗嘱消息。
    2. **设置 Will QoS**：指定遗嘱消息的服务质量等级。
    3. **设置 Will Retain**：指定遗嘱消息是否保留。
    4. **指定 Will Topic 和 Will Message**：在有效载荷部分填入遗嘱消息的主题和内容。

- **CONNACK 报文**
    CONNACK 报文是服务器对客户端发送的 CONNECT 报文的确认。
    MQTT v3.1 和 v3.1.1 格式

    | 字节偏移 | 名称           | 描述                                    |
    | -------- | -------------- | --------------------------------------- |
    | 0        | 固定报头       | 报文类型为 0x20                         |
    | 1        | 剩余长度       | 0x02，表示剩余报文长度为 2 字节         |
    | 2        | 连接确认标志位 | 0x00 表示无效，0x01 表示清除会话标志    |
    | 3        | 返回代码       | 0x00 表示连接已接受，其他值表示错误代码 |
  
    返回代码错误代码举例：

  - 0x01: 不支持的协议版本
  - 0x02: 无效的客户端标识符
  - 0x03: 服务器不可用
  - 0x04: 无效的用户名或密码
  - 0x05: 未授权
  
- **PUBLISH 报文**
  
    PUBLISH 报文用于客户端和服务器之间传递应用消息。
    MQTT v3.1 和 v3.1.1 格式

    | 字节偏移 | 名称       | 描述                                                |
    | -------- | ---------- | --------------------------------------------------- |
    | 0        | 固定报头   | 报文类型为 0x30（具体还包含 QoS、DUP、Retain 标志） |
    | 1        | 剩余长度   | 剩余报文长度，使用可变长度编码                      |
    | 2-3      | 主题名长度 | 主题名的长度（高字节在前）                          |
    | 4-...    | 主题名     | 包含主题的字符串                                    |
    | ...      | 报文标识符 | 若 QoS > 0，包含报文标识符                          |
    | ...      | 消息内容   | 有效载荷，包含应用层的数据                          |
  
    在 MQTT 协议中，`PUBLISH` 报文是用于客户端发布消息的关键数据包。该报文允许客户端向服务器发送消息，并且服务器根据订阅关系将消息转发给其他客户端。下面是 MQTT `PUBLISH` 报文的格式和详细字段解释。
  
  - **PUBLISH 报文格式**
    `PUBLISH` 报文由多个部分组成，包括固定报头、可变报头和负载。

    - **1. 固定报头（Fixed Header）**
      - **字节 1**：报文类型和标志位
      - 位 7-4：消息类型 (PUBLISH 为 `0011`, 即 0x3)
      - 位 3：DUP 标志（1 表示可能重复传输，0 表示首次发送）
      - 位 2-1：QoS 等级
      - `00`：QoS 0 (At most once)
      - `01`：QoS 1 (At least once)
      - `10`：QoS 2 (Exactly once)
      - `11`：保留，不能使用
      - 位 0：RETAIN 标志（1 表示消息应保留，0 表示不保留）
      - **字节 2+**：剩余长度（Remaining Length）
      - 剩余长度表示报文后续部分的字节总数，使用可变长度编码。

    - **2. 可变报头（Variable Header）**
      - **主题名长度（Topic Name Length）**：2 字节
      - **主题名（Topic Name）**：UTF-8 编码的字符串
      - **报文标识符（Packet Identifier，QoS > 0 时使用）**：2 字节，用于标识该 `PUBLISH` 报文。

    - **3. 负载（Payload）**
      - 实际消息内容，内容可以是任意字节序列，长度为剩余长度减去固定报头和可变报头的长度。

  - **PUBLISH 报文示例**
    - 假设我们要发布一条消息，主题是 `sensor/data`，消息内容为 `{"temp":22}`，使用 QoS 1（确保消息至少一次送达）。以下是一个示例报文的结构和解析：
  
       ```mathematica
       32 16 00 0B 73 65 6E 73 6F 72 2F 64 61 74 61 00 7B 22 74 65 6D 70 22 3A 32 32 7D
       ```

      - 1.**固定报头**：

        ```c
        0x32 = 0011 0010：
        ```

        - `0011` = PUBLISH (MQTT 消息类型)
        - DUP = 0（消息不是重复的）
        - QoS = 1（确保消息至少一次送达）
        - RETAIN = 0（不保留该消息）
        - 剩余长度为 `0x16`，即 22 字节（可变报头 + 负载的长度）。
      - 2.**可变报头**：
        - 主题名长度：`00 0B`，即 11 个字节
        - 主题名：`73 65 6E 73 6F 72 2F 64 61 74 61`，即 `sensor/data`
        - 报文标识符：`00 7B`，即 `123`（仅在 QoS > 0 时才有此字段）。

      - 3.**负载**：
        - 消息内容：`7B 22 74 65 6D 70 22 3A 32 32 7D`，即 `{"temp":22}`

    - **总结**

      - **固定报头**包含消息类型和标志。
      - **可变报头**根据 QoS 等级，包含主题名和报文标识符。
      - **负载**是实际要发布的消息内容。

    `PUBLISH` 报文是 MQTT 通信的核心，你可以通过 QoS 和 retain 标志来控制消息的可靠性和持久性。

- **SUBSCRIBE 报文**

    SUBSCRIBE 报文用于客户端向服务器请求订阅一个或多个主题。

    MQTT v3.1 和 v3.1.1 格式

    | 字节偏移 | 名称       | 描述                                                |
    | -------- | ---------- | --------------------------------------------------- |
    | 0        | 固定报头   | 报文类型为 0x82                                     |
    | 1        | 剩余长度   | 剩余报文长度，使用可变长度编码                      |
    | 2-3      | 报文标识符 | 表示当前订阅请求的唯一标识符                        |
    | 4-...    | 主题过滤器 | 主题字符串，后接订阅的 QoS（每个主题过滤器 1 字节） |

    在 MQTT 协议中，`SUBSCRIBE` 报文用于客户端向服务器发送订阅请求，以订阅一个或多个主题。服务器根据该报文将未来发布在这些主题上的消息推送给订阅客户端。`SUBSCRIBE` 报文仅在 QoS 等级 1 或 2 时有效。

  - **SUBSCRIBE 报文格式**

    `SUBSCRIBE` 报文由固定报头、可变报头和负载组成。

    - **1. 固定报头（Fixed Header）**

      - 字节 1：报文类型和标志位
      - 位 7-4：报文类型 (SUBSCRIBE 为 `1000`, 即 0x8)
      - 位 3：DUP 标志 (一般为 0)
      - 位 2-1：QoS 等级，必须为 1 或 2
      - 位 0：保留位，必须为 0
      - 字节 2+：剩余长度（Remaining Length）
      - 剩余长度表示报文后续部分的字节数，使用可变长度编码。

    - **2. 可变报头（Variable Header）**

      - 报文标识符（Packet Identifier）：2 字节
      - 用于标识该 `SUBSCRIBE` 报文（在 QoS 1 或 QoS 2 时必须设置）。

    - **3. 负载（Payload）**

      - 主题过滤器和 QoS 列表：
      - 每个主题过滤器为一个 UTF-8 编码的字符串，后跟 1 个字节表示 QoS 等级。
      - 负载可以包含多个主题过滤器及其 QoS。

  - **SUBSCRIBE 报文示例**

    假设客户端想要订阅两个主题：`sensor/temp` 和 `sensor/humidity`，QoS 为 1 和 2，以下是一个 `SUBSCRIBE` 报文的结构示例。

    ```mathematica
    82 16 00 10 00 0A 73 65 6E 73 6F 72 2F 74 65 6D 70 01 00 0E 73 65 6E 73 6F 72 2F 68 75 6D 69 64 69 74 79 02
    ```

    - 1.**固定报头**：
  
        ```c
        0x82= 1000 0010
        ```

      - `1000` = SUBSCRIBE 报文类型
      - QoS = 1
      - 剩余长度为 `0x16`（22 字节）。

    - **2.可变报头**：

      - 报文标识符：`00 10`，即 `16`
  
    - 3.**负载**：
      - 主题过滤器 1：
        - 主题名长度：`00 0A`，即 10 个字节
        - 主题名：`73 65 6E 73 6F 72 2F 74 65 6D 70`，即 `sensor/temp`
        - QoS：`01`（QoS 1）
      - 主题过滤器 2：
        - 主题名长度：`00 0E`，即 14 个字节
        - 主题名：`73 65 6E 73 6F 72 2F 68 75 6D 69 64 69 74 79`，即 `sensor/humidity`
        - QoS：`02`（QoS 2）

  - **总结**
    - **固定报头**：包含报文类型和 QoS 等信息。
    - **可变报头**：包含报文标识符，用于在 QoS 1 或 2 下进行响应匹配。
    - **负载**：包含要订阅的主题列表及其对应的 QoS 等级。

  `SUBSCRIBE` 报文允许客户端订阅多个主题，并为每个主题指定不同的 QoS，确保可靠性。

- **SUBACK 报文**

    SUBACK 报文是服务器对客户端发送的 SUBSCRIBE 报文的确认。

    MQTT v3.1 和 v3.1.1 格式

    | 字节偏移 | 名称       | 描述                                              |
    | -------- | ---------- | ------------------------------------------------- |
    | 0        | 固定报头   | 报文类型为 0x90                                   |
    | 1        | 剩余长度   | 剩余报文长度，使用可变长度编码                    |
    | 2-3      | 报文标识符 | 与 SUBSCRIBE 报文中使用的标识符相同               |
    | 4-...    | 返回代码   | 订阅的 QoS 等级（每个主题过滤器对应一个返回代码） |

    `SUBACK` 报文用于确认服务器已处理客户端的 `SUBSCRIBE` 请求。在 MQTT 中，客户端订阅主题时，服务器会返回一个 `SUBACK` 报文，以告知客户端是否成功订阅以及每个主题的 QoS 等级。

  - **SUBACK 报文格式**

    `SUBACK` 报文由固定报头、可变报头和负载组成。

    - **1. 固定报头 (Fixed Header)**
      - 字节 1：报文类型和标志位
        - 位 7-4：报文类型 (SUBACK 为 `1001`，即 0x9)
        - 位 3-0：保留位，必须为 0
      - 字节 2+：剩余长度 (Remaining Length)
        - 表示可变报头和负载的字节总数，使用可变长度编码。

    - **2. 可变报头 (Variable Header)**

      - 报文标识符 (Packet Identifier)：2 字节
      - 与 `SUBSCRIBE` 报文中的标识符匹配，以便客户端知道哪个订阅请求得到了回应。

    - **3. 负载 (Payload)**
      - 返回码 (Return Code) 列表：
        - 每个订阅主题对应一个返回码，表示订阅是否成功以及最终分配的 QoS 等级。返回码的含义如下：
          - `0x00`：成功 - QoS 0
          - `0x01`：成功 - QoS 1
          - `0x02`：成功 - QoS 2
          - `0x80`：失败（订阅请求被服务器拒绝）

  - **SUBACK 报文示例**

    假设客户端订阅了两个主题，服务器确认第一个主题订阅成功且 QoS 为 1，第二个主题订阅失败。服务器返回的 `SUBACK` 报文如下：

    ```c
    90 04 00 10 01 80
    ```

    1. **固定报头**：
       - `0x90` = `1001 0000`：SUBACK 报文类型，无特殊标志位。
       - 剩余长度：`0x04`（4 字节）。
    2. **可变报头**：
       - 报文标识符：`00 10`，即 16（与 `SUBSCRIBE` 报文中的标识符相同）。
    3. **负载**：
       - 返回码列表：
         - `0x01`：第一个主题成功订阅，QoS 为 1。
         - `0x80`：第二个主题订阅失败。

    - **SUBACK 报文生成代码示例**

        在 `libemqtt` 库中，解析 `SUBACK` 报文并处理订阅响应可以通过类似如下的代码实现：

        ```c
        void mqtt_handle_suback(uint8_t *message, int message_len) {
            if (message_len < 3) {
                printf("Invalid SUBACK message\n");
                return;
            }
        
            // 提取报文标识符
            uint16_t packet_id = (message[2] << 8) | message[3];
            printf("SUBACK for packet id: %d\n", packet_id);
        
            // 解析返回码
            for (int i = 4; i < message_len; i++) {
                uint8_t return_code = message[i];
                if (return_code == 0x00) {
                    printf("Subscription success: QoS 0\n");
                } else if (return_code == 0x01) {
                    printf("Subscription success: QoS 1\n");
                } else if (return_code == 0x02) {
                    printf("Subscription success: QoS 2\n");
                } else if (return_code == 0x80) {
                    printf("Subscription failed\n");
                } else {
                    printf("Unknown return code: 0x%02X\n", return_code);
                }
            }
        }
        ```

        该代码通过解析 `SUBACK` 报文的返回码，确认每个主题的订阅是否成功，并打印对应的 QoS 等级或错误信息。

  - **总结**
    - **固定报头**：指明报文类型 (SUBACK) 和剩余长度。
    - **可变报头**：包含与 `SUBSCRIBE` 请求匹配的报文标识符。
    - **负载**：返回码列表，表示每个主题的订阅结果。

    通过 `SUBACK` 报文，服务器可以向客户端反馈每个主题的订阅结果，包括 QoS 等级或订阅失败的情况。

- **UNSUBSCRIBE 报文**

    UNSUBSCRIBE 报文用于客户端向服务器请求取消订阅一个或多个主题。

    MQTT v3.1 和 v3.1.1 格式

    | 字节偏移 | 名称       | 描述                             |
    | -------- | ---------- | -------------------------------- |
    | 0        | 固定报头   | 报文类型为 0xA2                  |
    | 1        | 剩余长度   | 剩余报文长度，使用可变长度编码   |
    | 2-3      | 报文标识符 | 表示当前取消订阅请求的唯一标识符 |
    | 4-...    | 主题过滤器 | 包含一个或多个主题字符串         |

- **UNSUBACK 报文**

    UNSUBACK 报文是服务器对客户端发送的 UNSUBSCRIBE 报文的确认。

    MQTT v3.1 和 v3.1.1 格式

    | 字节偏移 | 名称       | 描述                                  |
    | -------- | ---------- | ------------------------------------- |
    | 0        | 固定报头   | 报文类型为 0xB0                       |
    | 1        | 剩余长度   | 0x02                                  |
    | 2-3      | 报文标识符 | 与 UNSUBSCRIBE 报文中使用的标识符相同 |

- **PINGREQ 报文**

    PINGREQ 报文用于客户端向服务器发送一个“心跳”请求，以确保连接的可用性。

    MQTT v3.1 和 v3.1.1 格式

    | 字节偏移 | 名称     | 描述                             |
    | -------- | -------- | -------------------------------- |
    | 0        | 固定报头 | 报文类型为 0xC0，剩余长度为 0x00 |

- **PINGRESP 报文**

    PINGRESP 报文是服务器对客户端发送的 PINGREQ 报文的响应。

    MQTT v3.1 和 v3.1.1 格式

    | 字节偏移 | 名称     | 描述                             |
    | -------- | -------- | -------------------------------- |
    | 0        | 固定报头 | 报文类型为 0xD0，剩余长度为 0x00 |

- **DISCONNECT 报文**

    DISCONNECT 报文用于客户端或服务器主动断开连接。

    MQTT v3.1 和 v3.1.1 格式

    | 字节偏移 | 名称     | 描述                             |
    | -------- | -------- | -------------------------------- |
    | 0        | 固定报头 | 报文类型为 0xE0，剩余长度为 0x00 |

#### 注意事项

v3.1 和 v3.1.1 之间的主要差异

- **协议名称**: 在 CONNECT 报文中，MQTT v3.1 使用 `MQIsdp` 作为协议名称，而 MQTT v3.1.1 使用 `MQTT`。
- **协议版本号**: 在 CONNECT 报文中，MQTT v3.1 的协议版本号为 `0x03`，而 v3.1.1 的协议版本号为 `0x04`。
- **错误处理**: 在 CONNACK 报文中，MQTT v3.1.1 增强了对错误处理的支持，提供了更多明确的返回代码。

这些报文格式在实现 MQTT 客户端或服务器时至关重要，确保了设备之间的互操作性。

是的，MQTT v3.1.1 在错误处理方面确实做了一些增强，特别是在 CONNACK 报文的返回代码部分，相较于 MQTT v3.1 版本提供了更详细的错误信息。具体来说：

MQTT v3.1 错误代码

在 MQTT v3.1 中，CONNACK 报文的返回代码相对简单，只有以下几种：

- **0x00**: 连接已接受。
- **0x01**: 连接被拒绝，不支持的协议版本。
- **0x02**: 连接被拒绝，标识符不合适。
- **0x03**: 连接被拒绝，服务不可用。
- **0x04**: 连接被拒绝，无效用户名或密码。
- **0x05**: 连接被拒绝，未授权。

MQTT v3.1.1 错误代码

MQTT v3.1.1 在此基础上保留了 v3.1 的所有错误代码，并进行了规范化，同时加强了错误代码的定义和使用。v3.1.1 主要改进在于：

- **更详细的错误代码描述**: 对每个错误代码的用途和适用场景进行了更详细的规范，确保了客户端和服务器之间的一致性。
- **明确的错误返回**: 对于不支持的协议版本，v3.1.1 明确要求返回 `0x01`，而在 v3.1 中，这一错误处理不够规范化。

具体来说，MQTT v3.1.1 的错误代码仍然保持不变，但在实现细节和错误处理方面更加严谨和明确。这些改进提高了客户端和服务器之间通信的可靠性和一致性。

#### 小结

熟悉 MQTT 报文格式是实现协议的关键，需根据实际需求选择合适的 QoS 等级。

------

## 实践案例

### 案例背景

描述案例的应用场景。

### 解决思路

分析问题并提出解决方案。

### 实现过程

- 步骤分解：分步讲解如何实现。
- 关键代码/操作：提供核心代码或操作截图。

### 结果展示

展示最终效果或输出。

### 优化建议

如何改进或扩展。

------

## 常见问题与解决方案

### FAQ

- Q：如何选择 QoS 等级？
  - A：根据可靠性需求选择，QoS 0 适用于非关键数据，QoS 1 和 2 适用于重要数据。

### 错误排查

- **连接失败** ：检查协议版本是否匹配。
- **消息丢失** ：确保 QoS 等级设置正确。

### 经验分享

- 使用调试工具（如 Wireshark）分析 MQTT 报文。

------

## 资源推荐

### 书籍

推荐相关经典书籍。

### 在线课程

优质课程链接或平台推荐。

### 工具与软件

- Mosquitto（MQTT Broker）
- Paho（MQTT 客户端库）

### 社区与论坛

可以交流讨论的平台（如 Stack Overflow、GitHub 等）。

------

## 总结与展望

### 学习收获

掌握了 MQTT 协议的基础知识及应用方法。

### 未来计划

深入研究 MQTT v5.0 的新特性，并尝试在大规模分布式系统中应用。

### 感谢

感谢菜鸟教程及开源社区提供的学习资料。

------

## 附录

### 术语表

- **Broker** ：消息代理。
- **QoS** ：服务质量等级。

### 参考文献

- [MQTT 入门 - 菜鸟教程](https://www.runoob.com/w3cnote/mqtt-intro.html?spm=5aebb161.2ef5001f.0.0.14b05171DeOnHe)

### 索引

如果内容较多，可以添加关键词索引。
