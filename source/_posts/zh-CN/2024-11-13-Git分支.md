---
title: Git分支
comments: true
published: true
lang: zh-CN
date: 2024-11-13 11:34:55
updated:
tags:
- 版本控制
- Git
categories:
- [工具/IDE, 版本控制, Git]
---

# Git 分支

> 参考资料：
>
> [Pro Git](https://git-scm.com/book/en/v2)
>
> [GitHub Docs](https://docs.github.com/en)
>
> [Markdown基础语法](https://www.markdownguide.org/basic-syntax/)

## 目录

- [Git 分支](#git-分支)
  - [目录](#目录)
  - [分支简介](#分支简介)
    - [核心概念](#核心概念)
  - [分支操作](#分支操作)
    - [创建分支](#创建分支)
    - [切换分支](#切换分支)
    - [查看分支](#查看分支)
    - [删除分支](#删除分支)
    - [合并分支](#合并分支)
  - [分支开发工作流](#分支开发工作流)
    - [Git Flow](#git-flow)
    - [GitHub Flow](#github-flow)
  - [远程分支](#远程分支)
    - [查看](#查看)
    - [跟踪](#跟踪)
    - [推送](#推送)
    - [拉取](#拉取)
    - [删除](#删除)
  - [变基](#变基)
    - [变基的风险](#变基的风险)
    - [变基 vs 合并](#变基-vs-合并)
    - [混合使用变基和合并的潜在问题](#混合使用变基和合并的潜在问题)
    - [避免混合使用变基和合并的原则](#避免混合使用变基和合并的原则)

## 分支简介

Git 分支是项目代码库中的一条独立的开发线。每个分支都有自己独立的提交历史，它允许开发人员在不影响主分支的情况下进行工作。分支是 Git 的一个关键特性，它帮助开发者并行开发新特性、修复 bug 或进行实验。

### 核心概念

- **主分支（main/master）**：Git 仓库中的默认分支，通常用于存放项目的稳定版本。
- **分支指针**：分支在 Git 中是一个指向某个提交的指针。每当你在分支上提交新更改时，分支指针会指向新的提交。
- **HEAD**：HEAD 是 Git 的一个特殊指针，它指向当前检出的分支或提交。HEAD 的作用是让 Git 知道你现在工作在哪个分支。

在 Git 中，每个“快照”存储的是仓库中所有文件在某一时刻的状态。而不是仅存储文件的变化或“差异”（区别于像其他版本控制工具，例如 SVN，后者以文件差异为基础）。如果文件在两次提交之间没有变化，Git 并不会重新存储整个文件，而是创建一个指向已有版本的链接，从而节省存储空间。快照描述了每个文件在该时刻的版本以及如何组织起来，因此你可以完整地恢复出项目的状态。

![提交对象及其树结构](https://git-scm.com/book/zh/v2/images/commit-and-tree.png)

一个快照通常包括以下内容：

1. **树对象（Tree Object）**：它表示项目的目录结构，记录了文件和子目录的关系。
2. **提交信息（Commit Object）**：它包含提交的元数据，如作者、日期、提交信息以及指向父提交的引用。
3. **Blob 对象**：存储的是文件的内容。对于没有变化的文件，Git 不会重新存储，只会创建一个指向现有 Blob 的引用。

表面上看，存储文件的完整内容可能会比存储差异占用更多空间，但在实际中，Git 的设计使得它的存储效率非常高，避免了不必要的空间浪费。

以下是一些 Git 优化存储的机制：

1. **对象去重**：对于没有变化的文件，Git 不会重新存储整个文件内容，而是用指针引用已有的 blob 对象。这意味着，即使你多次提交没有改变的文件内容，存储空间也不会增加。
2. **对象压缩（Packfile）**：Git 会定期对对象进行打包和压缩，将多个 blob 对象和其他元数据合并到一个 “packfile” 中，这极大地降低了存储空间。Git 的压缩算法非常高效，可以识别和消除重复的数据。
3. **增量存储**：尽管每次提交是一个完整快照，但在打包和压缩阶段，Git 会将历史中的对象以增量的方式存储（类似于存储差异），从而进一步减少实际存储的大小。

因此，虽然 Git 存储的是文件的快照，而不是差异，但通过以上机制，它在存储空间的使用上通常不会显著大于基于差异的版本控制系统，尤其在管理大量历史版本和文件时表现得更为高效。

---

## 分支操作

分支操作是 Git 中最常用的功能之一，允许你轻松创建、切换、查看和删除分支。以下是一些常见的分支操作。

### 创建分支

创建新分支非常简单，你可以使用 `git branch` 或 `git checkout -b` 命令。

```bash
# 创建一个名为 new-feature 的新分支
git branch <new-feature>

# 创建并切换到名为 new-feature 的分支
git checkout -b <new-feature>
```

### 切换分支

使用 `git checkout` 可以在分支之间切换，保持工作内容和上下文的连续性。

```bash
# 切换到名为 new-feature 的分支
git checkout new-feature
```

### 查看分支

要查看当前仓库中的所有本地分支，可以使用 `git branch` 命令。

```bash
# 查看所有本地分支
git branch

# 查看所有本地分支和远程分支
git branch -a

# 查看每一个分支的最后一次提交
git branch -v

# 已经合并到当前分支的分支
git branch --merged

# 尚未合并到当前分支的分支
git branch --no-merged 
```

当前分支会有一个星号（`*`）标记。

### 删除分支

当分支完成开发后，可以通过 `git branch -d` 删除本地分支。如果该分支还没有合并，使用 `-D` 参数强制删除。

```bash
# 删除本地分支 feature-xyz
git branch -d feature-xyz

# 强制删除未合并的分支
git branch -D feature-xyz
```

### 合并分支

在完成某个功能或修复 bug 后，你可能需要将分支合并到主分支（例如 `main`）中。使用 `git merge` 命令可以轻松地将两个分支的更改合并。

```bash
# 切换到主分支
git checkout main

# 将 new-feature 分支合并到 main
git merge <new-feature>
```

合并时，如果两个分支修改了同一部分代码，Git 会提示冲突。你需要手动解决冲突并完成合并。

```bash
# 查看冲突文件
git status

# 打开冲突文件，手动解决冲突

# 解决冲突后，添加已解决的文件
git add <conflicted-file>
git merge --continue
```

**快进合并（Fast-Forward Merge）:**

快进合并发生在目标分支（比如 `main`）没有新提交，且目标分支的末端正好与源分支（比如 `feature`）的最新提交相同。在这种情况下，Git 会直接将目标分支的指针移动到源分支的最新提交，而不需要生成新的合并提交。

举个例子：

1. 假设 `main` 分支和 `feature` 分支的历史如下：

   ```css
   A---B---C  (main)
            \
             D---E  (feature)
   ```

2. 如果你在 `feature` 分支完成了开发并准备合并回 `main`，并且 `main` 分支没有新提交，那么 Git 会执行一个快进合并：

   ```css
   A---B---C---D---E  (main, feature)
   ```

`--no-ff` 的作用:

使用 `--no-ff` 选项强制 Git 创建一个新的合并提交，即使合并本来可以通过快进合并完成。这意味着，即使 `feature` 分支的更改与 `main` 分支没有冲突，Git 仍然会为这个合并创建一个新的提交节点，这样合并的历史就会清晰地记录下来。

举个例子：

1. 仍然假设 `main` 和 `feature` 分支的历史如下：

   ```css
   A---B---C  (main)
            \
             D---E  (feature)
   ```

2. 使用 `git merge --no-ff feature` 合并 `feature` 分支到 `main` 分支时，Git 会强制创建一个新的合并提交，即使 `main` 分支没有新提交：

   ```css
   A---B---C--------F  (main)
            \     /
             D---E  (feature)
   ```

1. **保持历史清晰**：使用 `--no-ff` 使得每次分支合并都会生成一个合并提交，明确标识出分支合并的节点，这对于审查历史和理解项目的开发过程非常有帮助。
2. **便于回滚**：当你回滚某个特性分支时，使用 `--no-ff` 合并能够让你更容易地回退到合并点，而不是把提交历史扭曲得太过复杂。
3. **增强可视化**：通过强制合并提交，可以通过 `git log` 或其他历史查看工具轻松看到哪个分支在什么时候被合并，这对协作开发尤为重要

```bash
git merge --no-ff new-feature
```

---

## 分支开发工作流

为了高效管理分支和多人协作，团队通常会采用特定的分支工作流。常见的工作流包括 Git Flow 和 GitHub Flow。

### Git Flow

Git Flow 是一种比较复杂的分支管理模型，适合大型项目。它定义了多个分支角色，包括：

长期分支：

- `main\master`：存放稳定版本。
- `develop`：用于日常开发，后续开发或者测试稳定性。
- `next`:  更加前沿或实验性的功能开发，通常作为 `develop` 之后的下一步开发分支
- `feature`：每个新特性都有一个独立的分支。
- `release`：用于准备发布的分支。

主题分支：

- `hotfix`：用于紧急修复的分支。

```bash
# 创建一个 feature 分支
git checkout -b feature/awesome-feature develop
```

### GitHub Flow

GitHub Flow 是一种轻量级的工作流，适合快速迭代和持续集成。通常，开发者在 `main` 分支上创建特性分支，完成开发后通过 Pull Request 合并回 `main`。

---

## 远程分支

Git 不仅支持本地分支，还支持远程分支，这对于团队协作尤为重要。远程分支是指托管在远程仓库中的分支，通常与本地分支同步。

### 查看

要查看远程仓库的分支，可以使用 `git branch -r` 命令。

```bash
# 查看远程分支
git branch -r

# 查看本地分支的上游分支信息（是否是领先、落后）
git branch -vv
```

### 跟踪

从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 当克隆一个仓库时，它通常会自动地创建一个跟踪 `origin/master` 的 `master` 分支。

```bash
# 在本地建立一个跟踪远程分支的分支
git checkout -b <branch> <remote>/<branch>

# --track 快捷方式
git checkout --track origin/serverfix

# 你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支
git checkout serverfix

# 设置本地的 feature 分支跟踪远程的 origin/feature 分支
# 或修改 feature 分支的上游分支
# -u 或 --set-upstream-to 选项运行 git branch 来显式地设置
git branch -u origin/feature
```

Git 会根据本地分支的上游分支来决定拉取和推送的目标，不需要每次都指定远程分支，比如`git pull origin feature`

### 推送

当你在本地创建了新分支并完成开发后，可以将分支推送到远程仓库。

```bash
# 推送本地分支到远程仓库
git push origin new-feature

# 推送本地的分支，将其作为远程仓库的分支 
git push origin <localbranch>:<remotebranch>
```

### 拉取

当 `git fetch` 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。`git pull` 在大多数情况下它的含义是一个 `git fetch` 紧接着一个 `git merge` 命令。

> 由于 `git pull` 的魔法经常令人困惑所以通常单独显式地使用 `fetch` 与 `merge` 命令会更好一些。

```bash
# 拉取远程仓库的更新
git fetch <remote> <branch>

# 拉取远程分支的更新
git fetch origin

# 拉取远程仓库的所有更新并更新远程跟踪分支
git fetch --all
```

### 删除

基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。

```bash
git push origin --delete <branch>
```

---

## 变基

变基（Rebase）是一种将一个分支的修改应用到另一个分支的方法。与合并（Merge）不同，变基会重新写提交历史，使得历史更加线性。

变基的优点是：

- **线性历史**：所有提交会按时间顺序排列，没有合并提交，使得历史更加清晰。
- **避免冲突的累积**：每个提交都被应用到目标分支的新历史中，可以在每次变基时解决冲突，而不是将所有冲突积累到最后。

原理是首先找到这两个分支（即当前分支 `experiment`、变基操作的目标基底分支 `master`） 的最近共同祖先 `C2`，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 `C3`, 最后以此将之前另存为临时文件的修改依序应用。

![将 `C4` 中的修改变基到 `C3`](https://git-scm.com/book/zh/v2/images/basic-rebase-3.png)

```bash
# 切换到 experiment 分支
git checkout experiment

# 将 master 分支的更改变基到 feature 分支
git rebase master
```

与合并一样，变基过程中如果遇到冲突，Git 会暂停变基操作并要求你解决冲突。

```bash
# 查看冲突文件
git status

# 打开并解决冲突

# 解决冲突后，继续变基
git rebase --continue
```

假设你希望将 `client` 中的修改合并到主分支并发布，但暂时并不想合并 `server` 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 `git rebase` 命令的 `--onto` 选项， 选中在 `client` 分支里但不在 `server` 分支里的修改（即 `C8` 和 `C9`），将它们在 `master` 分支上重放：

```bash
# 可以认为已master和server的共同祖先节点，在master重新写提交历史
git rebase --onto master server
```

![截取主题分支上的另一个主题分支，然后变基到其他分支](https://git-scm.com/book/zh/v2/images/interesting-rebase-2.png)

### 变基的风险

遵守一条准则

:star:如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。

变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 `git rebase` 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。

> 只使用 **变基（rebase）** 或 **合并（merge）** 操作，不将这两者混合使用，通常情况下不会发生类似你所说的被覆盖提交的问题。这是因为这两种操作有不同的工作方式，且彼此独立，可以避免冲突的发生。

### 变基 vs 合并

- **合并**（Merge）：会保留所有分支的提交历史，合并时产生一个新的合并提交，可能会出现“分支合并”的记录。
- **变基**（Rebase）：将一个分支的提交线性地应用到另一个分支上，使得提交历史更加简洁。适用于保持清晰的提交历史，但会改变历史。

| 特性           | 变基（Rebase）                                           | 合并（Merge）                        |
| -------------- | -------------------------------------------------------- | ------------------------------------ |
| **历史清晰度** | 生成线性的提交历史                                       | 会创建合并提交，历史有分叉（非线性） |
| **历史修改**   | 修改提交历史，重写提交基础                               | 保留所有提交，不会修改历史           |
| **适用场景**   | 当你希望保持提交历史的简洁时，避免合并提交               | 当你想保留所有分支的提交历史时       |
| **冲突解决**   | 变基时可能会多次需要解决冲突，每次提交都会有机会解决冲突 | 合并时可能会在最后一次合并时解决冲突 |

---

### 混合使用变基和合并的潜在问题

当你将 **变基** 和 **合并** 操作混合使用时，可能会引发一些问题，特别是在涉及到已经推送到远程仓库的分支时。常见的情况包括：

- **强制推送和覆盖提交**：如果你在变基后推送了更新（例如你本地的提交被重新应用），而远程仓库已经有了与这些提交冲突的提交，可能会发生 **强制推送** 和 **覆盖提交** 的情况，这样会丢失其他人的提交。
- **多次变基后的复杂历史**：如果你在多个分支上多次使用变基，提交历史可能会变得复杂，容易出错，尤其是如果团队成员同时在多个分支上进行工作时。
- **合并提交的重复**：如果你在变基后又进行合并操作（例如变基后合并回主分支），可能会产生不必要的合并提交，破坏历史的简洁性。

### 避免混合使用变基和合并的原则

如果你不想发生类似的覆盖问题，可以遵循以下原则：

- **单一操作流**：在个人开发过程中，如果你只是在本地修改，可以选择使用 `git rebase` 来保持历史线性。如果你需要将本地分支合并回主分支或共享分支，使用 `git merge` 来避免历史被重写。
- **避免强制推送**：如果你已经推送了变基的提交到远程仓库，避免执行 `git push --force`，因为这会覆盖其他人的修改。在团队协作中，强制推送可能会导致丢失别人提交的代码。
- **明确的工作流**：可以在团队中明确使用某一种方式，建议使用变基保持干净的历史，或者在某些情况下使用合并来保留提交的上下文和历史。
